 https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU1MzQ0NjU0Ng==&action=getalbum&album_id=1337119604577058816&scene=173&from_msgid=2247484296&from_itemidx=1&count=3&nolastread=1#wechat_redirect
# 数据结构
![](https://pic2.zhimg.com/80/v2-d3ff88ce8432ccee1e1a6456eddd7051_720w.jpg)
## 常见的数据结构
1. 栈（Stack）：栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。 
   
2. 队列（Queue）：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。
3. 数组（Array）：数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。
4. 链表（Linked List）：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。
5. 树（Tree）：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。
6. 图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
7. 堆（Heap）：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。
8. 散列表（Hash table）：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。
## 常用算法
1. 检索：检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。
   
2. 插入：往数据结构中增加新的节点。
3. 删除：把指定的结点从数据结构中去掉。
4. 更新：改变指定节点的一个或多个字段的值。
5. 排序：把节点按某种指定的顺序重新排列。例如递增或递减。
## 逻辑结构
1. 线性结构：数据元素之间存在一对一的关系
   
2. 树形结构：数据元素之间存在一对多的关系
3. 图形结构：数据元素之间存在多对多的关系
4. 集合结构：数据元素属于同一个集合
![](https://pic2.zhimg.com/80/v2-2575aa37a54fbf5c8ede82e28c0282e1_720w.jpg)
## 存储结构
1. 顺序存储：逻辑上相邻的元素存储在物理位置相邻的存储单元中
2. 链式存储：在数据元素中添加一些地址域或者辅助结构，用于存放数据元素之间的关系
![](https://pic2.zhimg.com/80/v2-5824a5b8a5505e0c4daa0f9955ef8169_720w.jpg)
# 算法
- 输入：有零个或多个输入量
- 输出：产生至少一个输出量
- 确定性：算法的指令清晰，无歧义
- 有限性：算法的指令执行次数有限，执行时间有限
![](https://pic1.zhimg.com/80/v2-8fd0e2b9f83cb9891f6d47822cc72aa4_720w.jpg)
### 计算机解决生产问题的过程可以分为下面五个步骤:
1. 问题的理解：搞清楚问题的输入、要求和输出
2. 数据结构设计：设计能处理问题中数据的数据结构，还要设计能支持算法策略的数据结构
3. 算法设计：选择算法策略，用适当的方式描述和逐步细化算法步骤
4. 算法分析：发现有优化的地方，返回第二步，重新设计数据结构和算法
5. 程序实现：用计算机编程，定义数据结构，编写代码实现，并调试和运行
![](https://mmbiz.qpic.cn/mmbiz_png/iaJPvricOSmTfleH8vSWnQNquI3O27EANfXaib2JvVnEZkG1Xh62ju8C8EQctiaT4FDdWibqiabFaukj6qJmYRhVn4ibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
## 时间复杂度
 编程实现算法后，算法就是由一组语句构成，算法的执行效率就由各语句执行的次数所决定。一个算法花费的时间与算法中语句的执行次数成正比，哪个算法语句执行词次数多，它花费的时间就越多，把时间复杂度为T(n)，一般情况下，算法的基本操作重复执行的次数是关于模块 n 的一个函数f(n), 因此，我们可以把算法的时间复杂度记做：T(n)=O(f(n))
 ![](https://img2018.cnblogs.com/blog/1477786/201906/1477786-20190623122505672-661858047.webp)
## 求绝对值
我们需要一个整数的绝对值，在算法设计上，只需要输入的值为负数时，返回它的相反数，其他情况返回本身，代码如下：
```c
public static int abs(int a){
    return a < 0 ? -a : a;
}
```
该代码中只有一条运算指令语句，时间复杂度为O(1)
## 数组求和
已知一个整型数组，需要对数组内所有元素求和，如果只是通过遍历所有元素而不使用其他方法进行求和，可以使用如下代码实现：
```c
public static int sum(int[] a){
    int s = 0;
    for (int i : a){
        s +=i;
    }
    return s;
}
```
由代码可知，如果输入数组的大小为n，执行语句中初始化赋值需要时间O(1)，循环语句中的赋值操作需要时间为O(1)*n，所以语句执行的时间为：O(1)+O(1)*N=O(N+1)=O(N)
## 二分查找
已知一个有序数组，需要在数组中找到某个元素的位置，我们可以通过二分法来实现，代码如下：
```c
public static int binarysearch(int[] a,int b){
    int i, r=0, l=a.length;
    while(r <= 1){
        i = (r + 1) / 2;
        if(a[i]<b){
            r = i + 1;
        }else if (a[i] > b){
            l = i - 1;
        }else{
            return i;
        } 
    }
    return -1;
}
```
我们要计算该代码的时间复杂度，关键就是算循环的次数，可以归纳一下，在最糟糕的情况下：
- 在4个元素中查找需要2步；
- 在8个元素中查找需要3步；
- 在16个元素中查找需要4步；
- 在n个元素中查找需要log2n步；

也就是说在n个元素中，需要当n/(2^k)=1时，才能找到目标元素，由此也可得到k=1og2n，所以二分查找的时间复杂度为O(log n)。
## 冒泡排序
已知一个整型数组，需要使用冒泡算法来进行排序，代码如下
```c
public static int[] bubblesort(int[] a){
    int temp;
    for(int i = 0 ; i < a.length -1;i++){
        for(int j =0;j<a.length -1-i;j++){
            if(a[j] > a[j + 1]){
                temp =a [j];
                a[j]=a [j + 1];
                a[j + 1] =temp; 
            }
        }
    }
    return a;
}
```
## 空间复杂度
衡量算法性能的另一个重要方面，就是算法需使用的储存空间量，即算法空间复杂度。我们希望对于同样的输入规模，在时间复杂度相同的前提下，算法所占的空间越少越好。每次基本操作只会涉及到常数规模的空间，所以我们在分析和讨论算法时，只关注时间复杂度。当然，空间复杂度在空间效率非常在乎的应用场景时，或者问题的输入规模极为庞大时，也有其存在意义。
# 线性表的定义与实现
## 定义
假设我们有n个同类型数据元素的有限序列，记为：
    L=(a1,a2,a3,...,ai,...an)
它就构成了一个线性表。前面说过任何一种逻辑结构都可以使用两种储存结构（顺序存储,链式存储）来实现，使用顺序存储时，会在内存中分配连续的空间来存储数据元素，在程序代码中经常使用数组来实现。但问题来了，很多时候我们无法知道到底预先分配多大的空间合适，如果数据量较大时，内存中不纯在那么大的连续空间，所以会导致内存分配失败。这个时候，就可以使用链式存储来实现，具体选用哪种方案根据需求决定。

链式存储可以使用任何地址的空间存放数据元素，也就是可以空间不连续，他的实现也很简单，就是在存放每个数据结点，里面包括数据元素和一个指向后一个数据元素的引用（或者指针）
![](https://mmbiz.qpic.cn/mmbiz_png/iaJPvricOSmTffWshRfc26SmAa34YbnsXSicKga8QQH15224husUZr3y9F2ScggddoXricQx5icZ0r4ofHlclSaotvQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
- 使用顺序存储实现的线性表叫做顺序表
- 使用链式存储实现的线性表叫做链表
## 线性表基本操作分析
### 插入
我们已经创建了两种存储结构的线性表，数据元素为（a1,a2,a3,a4,a5），现在需要在 a2 的后面插入一个新的数据元素 a6,在使用顺序存储实现时，我们需要将 a2 后面的数据 a3,a4,a5 都要往后移动才能插入。在使用链式存储时，而只需要定位到 a2，然后把 a2.next 赋给新结点 a6.next，再把新结点 a6 赋给 a2.next，通过引用的交换就可以将新数据插入到链表中，由此可看出链表比顺序表的插入效率更高。
![](https://mmbiz.qpic.cn/mmbiz_png/iaJPvricOSmTffWshRfc26SmAa34YbnsXSNkWmseD2WLbmTfzgqm3WNIPvUtJdfJQHCvyuqIEAODI3iaRzVCo3LnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
### 删除
如果我们要删除线性表中的一个数据元素，和插入有点类似，比如需要在给定线性表(a1,a2,a3,a4,a5)中删除第三个元素a3，在顺序结构中，需要把a3后面的数据a4,a5都要往前移动，再把最后一个数据元素清空。在链式结构中，只需要定位到a3前一个元素 a2，然后把a2.next.next赋值给a2.next就可以删掉链表中的a3，所以,链表的删除操作不需要移动后面的元素，效率比顺序表要高。
![](https://mmbiz.qpic.cn/mmbiz_png/iaJPvricOSmTffWshRfc26SmAa34YbnsXSGIRyibN1gg3qc5vibcKu7AtD4JkZcGicYcpaxXIkFMJ9HnxyUqJf9444w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
### 查找
如果我们需要在线表中通过下标查找数据元素，在顺序存储中，因为数据有序存放在一个内存段中的，所以直接可以使用下标来获取，而在链式存储中，数据是无序的，所以要从头结点开始遍历来找到对应下标的数据元素，由此可见，链表的查找效率低于顺序表。
![](https://mmbiz.qpic.cn/mmbiz_png/iaJPvricOSmTffWshRfc26SmAa34YbnsXS3cot1VK04qBmKTdxicCt9XbkhaNShXGOk5rZa7Uez8zzOO3GNTjQz2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
### 遍历
当我们要对一个线性表进行遍历时，虽然不管是使用顺序存储还是链式存储，都要对所有元素进行读取，效率看上去不相上下，但不要忘了，顺序表是存在连续空间上的，所以在遍历的时候只需要进行地址偏移就可以读取到所有元素，而链表每读取元素的后一个元素，都要进行一次寻址操作，所以效率也是低于顺序表的
![](https://mmbiz.qpic.cn/mmbiz_png/iaJPvricOSmTffWshRfc26SmAa34YbnsXScEJXgiaEpDmjLudkkxmiaKjOUhtDIwDUQ3pFYiaCHMkPmicrY03r7ZibicpQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 
# 线性链表
- 数据结构中的每一个结点对应于一个存储单元，这种存储单元称为存储结点，简称结点。
- 结点由两部分组成
  -  用于存储数据元素值，称为数据域；
  -  用于存放指针，称为指针域，用于指向前一个或后一个结点。


- 在链式存储结构种中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间的逻辑关系可以不一致，而数据元素之间的逻辑关系是链式存储方式即可用于表示线性结构，也可用于表示非线性结构。
- 线性链表，head称为头指针，head=null（或0）称为空表，如果是两指针：
  - 左指针（llink）指向前件结点，
  - 右指针（rlink）指向后件结点。 
- 线性链表的基本运算：查找、插入、删除。
## 单链表
- 指针域中存储的信息称做指针或链。


- N个结点链结成一个链表，由于此链表的每一个结点中包含一个指针域，故又称线性链表或单链表。
## 循环链表
- 循环链表是单链表的变性


- 循环链表最后一个结点的next指针不为空，而是指向了表的前端，为了简化操作，在循环链表中往往加入表头结点。
- 循环链表的特点是：只要知道表中某一结点的地址，就可搜寻到所有其他结点的地址。
## 双向链表
- 双向链表是指在前驱和后继反向都能游历（遍历）的线性链表
- 在双向链表中，每一个结点除了数据域外，还包括两个指针域，一个指针指向该结点的后续结点，另一个指针指向它的前趋结点。
- 通常采用带表头结点的循环链表形式。

## 用指针实现表
- 用数组实现表时，利用了数组单元在物理位置上的邻接关系表示表元素之间的逻辑关系


  - 优点是：无须为表示表元素之间的逻辑关系增加额外的存储空间。可以方便地随机存取表中任一位置的元素


  - 缺点是；插入和删除运算不方便，除表尾位置外，在表的其他位置上进行插入或删除操作都需移动大量元素，效率较低。
- 由于数组要求占用连续的存储空间，因此在分配数组空间时，只能预先估计表的大小再进行存储分配。当表长变化较大时，难以确定数组的合适的大小

## 顺序表与链表的比较
- 顺序表的存储空间可以是静态分配的，也可以是动态分配的。
  - 链表的存储空间是动态分配的。

- 顺序表可以随机或顺序存取。
  - 链表只能顺序存取。

- 顺序表进行插入/删除操作平均需要移动近一半元素。
  - 链表则修改指针不需要移动元素。

- 若插入/删除仅发生在表的两端，宜采用带尾指针的循环链表。、
- 存储密度=结点数据本身所占的存储量/结点结构所占的存储总量。
- 顺序表的存储密度 = 1，链表的存储密度 < 1
- <font color=red>总结</font>：
  - 顺序表是用数组实现的，链表是用指针实现的。
  - 用指针来实现的链表，结点空间是动态分配的，链表又按链接形式的不同，区分为单链表、双链表和循环链表。

# 栈和队列
- 栈是限定在一端进行插入与删除的线性表，允许插入与删除的一端称为栈顶，不允许插入与删除的另一端称为栈底。
- 栈按照"先进后出"(filo)组织数据，栈具有记忆作用。
- 用top表示栈顶位置，用bottom表示栈底。
- 栈的基本运算
  - 插入元素称为入栈运算
  - 删除元素称为退栈运算
  - 读栈顶元素是将栈顶元素赋给一个指定的变量，此时指针无变化。
- 队列是允许在一端(队尾)进入插入，而在另一端(队头)进行删除的线性表。


- rear指针指向队尾，front指针指向队头。
- 队列是"先进行出"(fifo)或"后进后出"(lilo)的线性表
- 队列运算包括


  - 入队运算：从队尾插入一个元素；
  - 退队运算：从队头删除一个元素。 
- 循环队列：s=0表示队列空，s=1且front=rear表示队列满

# 栈
- 是限定仅在表尾进行插入或删除操作的线性表。
- 栈是一种后进先出（last in fist out）/先进后出的线性表

## 链栈的基本操作
- 进栈运算
  - 为待进栈元素X申请一个新结点，并把X赋给该结点的值域


  - 将X结点的指针域指向栈顶结点
  - 栈顶指针指向X结点，即使X结点成为新的栈顶结点

  - 算法
```c
SNode *Push_L(SNode * top,ElemType X)
{
  SNode * P;
  P = (SNode*)malloc(sizeof(SNode));
  P->data=x;
  P->next=top;
  top=p;
  return top;
}
```
- 出栈运算
  - 检查栈是否为空，若为空，进行错误处理。
  - 取栈顶指针的值，并将栈顶指针暂存
  - 删除栈顶结点 
  - 算法
```c
SNope *pop_(SNode * top,ElemType *y)
{
  SNode *p;
if(top==null)return 0;/*链栈为空*/
else{
  p=top;
  *y=p->data;
  top=p->next;free(p);
  return top;
  }

}
```
- 取栈顶元素
  - 算法
  ```c
  void gettop(SNode * top)
  {
    if(top!=null)
    return(top->data);/*若栈非空，则返回栈顶元素*/
    else
    return(null);/*否则，则返回null*/
  }
  ```

# 队列
- 是只允许在表的一端进行插入，而在另一端进行删除的运算受限的线性表


- 其所有的插入均限定在表的一端进行，该端称为队尾（Rear）；所有的删除则限定在表的另一端进行，该端则称为队头（Front）。
- 如果元素按照a1，a2，a3....an的顺序进入队列，则出队列的顺序不变，也是a1，a2，a3....an。
  - 所以队列具有先进先出（First In First Out，简称FIFO）/后进后出特性。
- 如车站排队买票，排在队头的处理完走掉，后来的则必须排在队尾等待。在程序设计中，比较典型的例子就是操作系统的作业排队。
- 队列的顺序存储结构称为顺序队列，顺序队列实际上是运算受限的顺序表，和顺序表一样，顺序队列也是必须用一个数组来存放当前队列中的元素。


- 由于队列的队头和队尾的位置是变化的，因而要设两个指针分别指示队头和队尾元素在队列中的位置。循环队列是为了克服顺序队列中“假溢出”，通常将一维数组Sq.elem[0]到Sq.elem.[MaxSize-1]看成是一个首尾相接的圆环，即Sq.elem[0]与Sq.elem .[maxsize-1]相接在一起。
  - 这种形式的顺序队列称为循环队列。
  - 用线性链表表示的队列称为链队列。


  - 链表的第一个节点存放队列的队首结点，链表的最后一个节点存放队列的队尾首结点，队尾结点的链接指针为空。
  - 另外还需要两个指针（头指针和尾指针）才能唯一确定
    - 头指针指向队首结点
    - 尾指针指向队尾结点 

# 树与二叉树
- 树是一种简单的非线性结构，所有元素之间具有明显的层次特性


- 在树结构中
  - 每一个结点只有一个前件，称为<font color=red>父节点</font>


  - 没有前件的结点只有一个，称为<font color=red>树的根结点，简称树的根</font>
  - 每一个结点可以有多个后件，称为<font color=red>该结点的子结点</font>
  - 没有后件的结点，称为<font color=red>叶子结点</font>
  - 一个结点所拥有的后件的个数，称为<font color=red>该结点的度</font>
  - 所有结点中最大的度，称为<font color=red>树的度</font>
  - 树的最大层次，<font color=red>称为树的深度</font>
- 二叉树的特点
  - 非空二叉树只有一个根结点
  - 每一个结点最多拥有两棵子树，且分别称为该结点的左子树与右子树
- 二叉树的基本性质
  - 在二叉的第K层上，最多有2K-1(K≥1)个结点
  - 深度为m的二叉树最多有2m-1个结点
  - 度为0的结点(即叶子结点)总是比度为2的结点多一个
  - 具有n个结点的二叉树，其深度至少为[log2n]+1,其中[log2n]表示取log2n的整数部分
  - 具有n个结点的完全二叉树的深度为[log2n]+1
  - 设完全二叉树共有n个结点。如果从根结点开始，按层序(每一层从左到右)用自然数1,2,...n给结点进行编号(k=1,2....n)
  - 有以下结论: 


    - 若k=1，则该结点为根结点，它没有父结点；若K>1，则该结点的父结点编号为int(k/2);


    - 若2k ≤ n，则编号为k的结点的左子结点编号为2K;否则该结点无左子结点（也无右子结点）
    - 若2k+1 ≤ n，则编号为K的右子结点编号为2K+1;否则该结点无右子结点
 -  满二叉树是指除最后一层外，每一层上的所有结点有两个子结点，则k层上有2k-1个结点深度为M的满二叉树有2m-1个结点。
 -  完全二叉树是指除最后一层外，每一层上的结点数均达到最大值，在最后一层上只缺少右边的若干结点。
 -  二叉树存储结构采用链式存储结构，对于满二叉树与完全二叉树可以按层序进行顺序存储
 -  二叉树的遍历：
    -  前序遍历(dlr)，首先访问根结点，然后遍历左子树，最后遍历右子树；


    -  中序遍历(ldr),首先遍历左子树，然后访问根结点，最后遍历右子树；
    -  后序遍历(lrd)，首先遍历左子树，然后访问遍历右子树，最后访问根节点。

# 树
  - 树 
    - 结点的度
       - 结点拥有子节点的个数


    - 树的度


      - 该树中最大的度数
    - 叶子结点
      - 度为零的结点
    - 分支结点
      - 度不为零的结点
    - 内部结点
      - 除根结点之外的分支结点
    - 开始结点
      - 根结点又称为开始结点
  - 结点的高度：该结点到各结点的最长路径的长度
  - 森林：m(m≥0) 棵互不相交的树的集合。将一颗非空树的根结点删去，树就变成一个森林；反之，给m棵独立的树增加一个根结点，并把这M棵树作为该结点的子树，森林就变成一棵树
  - 结点的层数和树的深度
    - 结点的层数：根结点的层数为1，其余结点的层数等于其双亲结点的层数加1
  
    - 堂兄弟；双亲在同一层的结点互为堂兄弟
    - 数的深度：树中结点的最大层数称为树的深度
    - <font color=red>注意:要弄清结点的度、树的度和树的深度的区别</font>
    - 树中结点之间的逻辑关系是"一对多"的关系，树是一种非线性的结构
  - 树的遍历
    - 先序遍历：


      - 访问根结点


      - 先序遍历根的左子树
      - 先序遍历根的右子数
    - 中序遍历：
      - 中序遍历左子树
      - 访问根结点
      - 中序遍历右子树
    - 后序遍历：
      - 后序遍历左子树
      - 后序遍历右子树
      - 访问根节点
  - 最优二叉树(哈夫曼树)
    - 最小两结点数相加的值与次小结点数合并


  - 已知一颗二叉树的前根序序列和中根序序列，构造该二叉树的过程如下

    - 根据后根序序列的最后一个元素建立根结点

    - 在中根序序列中找到该元素，确定根结点的左右子树的中根序序列
    - 在后根序序列中确定左右子树的后根序序列
    - 由左子树的后根序序列和中根序序列建立左子树
    - 由右子树的后根序序列和中根序序列建立右子树 
  
# 图
-   G= ( V , E ) = ( 顶点，边）
无向完全图有n（n - 1）/ 2 个边 ，有向完全图有n（n - 1）个边 。n表结点。
边无向()，弧有向<>

- 迪杰斯特拉(dijkstra)算法
  - 是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等，注意该算法要求图中不存在负权边

- 费洛伊德(floyd)算法<邻接矩阵求>
  - 是解决任意两点间的最短路径的一种算法,可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。floydwarshall算法的时间复杂度为O(N3),空间复杂度为O(N3)


- 普里姆(Prim)算法
  - 基本思想
    - 从连通网络N={V,E}中的某一顶点u0出发，选择与它关联的具有最小权值的边(u,v)
  ，把它的顶点加入到集合s中，如此继续下去，直到网络中的所有顶点都加入到生成树顶点集合S中为止。

- 克鲁斯卡尔(Kruskal)算法
 - 设有一个有N个顶点的连通网络N={V,E}最初先构造一个只有n个顶点，没有
  边的非连通图T={v,∅}，图中每个顶点自成一个连通分支。当在E中选到一条
  具有最小权值的边时，若该边的两个顶点落在不同的连通分支上，则将此边加入到T中；否则将此边舍去，重新选择一条全值最小的边。如此重复下去，直到所有顶点在同一个连通分支上为止。

# 查找计数
- 顺序查找的使用情况： 
  - （1）线性表为无序表； 
  
  - （2）表采用链式存储结构。 
- 二分法查找只适用于顺序存储的有序表，对于长度为n的有序线性表，最坏情况只需比较log2n次。

# 排序计数
  - 排序是指将一个无序序列整理成按值非递减顺序排列的有序序列


  - 交换类排序法：
    - 冒泡排序法，需要比较的次数为N(N-1)/2
    - 快速排序法
  - 插入类排序法
    - 简单插入排序法，最坏情况需要N(N-1)/2次比较


    - 希尔排序法，最坏情况需要O(n1.5)次比较
  - 选择类排序法
    - 简单选择排序法
  - 最坏情况需要N(N-1)/2次比较
  - 堆排序法，最坏情况需要O(nlog2n)次比较
![](https://img2018.cnblogs.com/blog/1477786/201906/1477786-20190623130158242-1359182970.webp)
- 排序小结
  - 就平均时间性能而言，快速排序最佳。但在最坏情况下不如堆排序和归并排序。（归并排序对n较大时适用）


  - 当序列中的记录“基本有序”或n值较小时，直接插入排序是最佳的方法，因此常将它与其他排序方法结合使用，如快速排序，归并排序等
  - 基数排序的时间复杂度也可写成O(d*n)，因此它最适用于n值很大而关键字较小的序列
  - 稳定的排序方法：简单排序。不稳定的排序方法：快速排序，堆排序。
  - 一般来说，排序过程中的“比较”是在相邻的两个记录的关键字之间进行的排序方法是稳定的